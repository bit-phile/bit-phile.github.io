<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Infra on bitPhile</title><link>https://nitinsharmacs.github.io/tags/infra/</link><description>Recent content in Infra on bitPhile</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 12 Mar 2023 10:38:56 +0530</lastBuildDate><atom:link href="https://nitinsharmacs.github.io/tags/infra/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker Volume</title><link>https://nitinsharmacs.github.io/tech/docker/docker-volume/</link><pubDate>Sun, 12 Mar 2023 10:38:56 +0530</pubDate><guid>https://nitinsharmacs.github.io/tech/docker/docker-volume/</guid><description>&lt;h1 id="understanding-docker-volume-thoroughly">Understanding Docker Volume Thoroughly&lt;/h1>
&lt;h2 id="agenda">Agenda&lt;/h2>
&lt;ol>
&lt;li>Abstract&lt;/li>
&lt;li>Container layer and its data on docker host machine&lt;/li>
&lt;li>What are the flaws of storing data in the container layer?&lt;/li>
&lt;li>What is the solution?&lt;/li>
&lt;li>Using docker volume&lt;/li>
&lt;li>Conclusion&lt;/li>
&lt;/ol>
&lt;h2 id="abstract">Abstract&lt;/h2>
&lt;p>A Docker container is an independent process comprising the application and its dependencies. Container has its processes, file system, and networks independent of the host machine.&lt;/p>
&lt;p>Creating a resource in the running container stores that resource in the Read-Write layer or Container layer. This is a temporary storage mechanism. It is accessible until the container is running. Once the container is removed, all the data goes.&lt;/p></description></item><item><title>Docker Image Layers</title><link>https://nitinsharmacs.github.io/tech/docker/docker-image-layers/</link><pubDate>Sun, 05 Mar 2023 13:00:22 +0530</pubDate><guid>https://nitinsharmacs.github.io/tech/docker/docker-image-layers/</guid><description>&lt;h1 id="deep-dive-into-docker-image-layers">Deep dive into Docker Image Layers&lt;/h1>
&lt;p>In my previous post &lt;a href="https://nitinsharmacs.github.io/tech/docker/getting-started-with-docker">Getting started with docker&lt;/a>, I explained the basics of docker. In this post, we will be deep diving into docker image layers. We will be covering the following topics in this post,&lt;/p>
&lt;ol>
&lt;li>What are docker image layers?&lt;/li>
&lt;li>Why does knowing docker image layers matter?&lt;/li>
&lt;li>Where do these intermediary images reside and how to see them?&lt;/li>
&lt;li>What are the constituents of a docker container size?&lt;/li>
&lt;/ol>
&lt;p>Are you ready? Yes! So let&amp;rsquo;s start&amp;hellip;&lt;/p></description></item><item><title>Getting Started With Docker</title><link>https://nitinsharmacs.github.io/tech/docker/getting-started-with-docker/</link><pubDate>Sun, 26 Feb 2023 11:53:43 +0530</pubDate><guid>https://nitinsharmacs.github.io/tech/docker/getting-started-with-docker/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>Developing software and applications is getting more complex day by day. This introduces the complexity of running and deploying the applications in different machines or environments. It also includes making sure it works everywhere no matter what the architecture of the host machine is.&lt;/p>
&lt;p>Applications running in the same environment can conflict with other applications. This can cause malfunctions and make application development less effective.&lt;/p>
&lt;p>To solve this problem we need isolation and a virtual machine is one way to achieve this. We can have different virtual machines to run the applications that will be independent of other applications environments.&lt;/p></description></item></channel></rss>