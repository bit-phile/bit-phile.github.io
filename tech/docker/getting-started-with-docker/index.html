<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Getting Started With Docker | bitPhile</title><meta name=keywords content="docker,infra,kubernetes,container,containerisation,containerization"><meta name=description content="Introduction Developing software and applications is getting more complex day by day. This introduces the complexity of running and deploying the applications in different machines or environments. It also includes making sure it works everywhere no matter what the architecture of the host machine is.
Applications running in the same environment can conflict with other applications. This can cause malfunctions and make application development less effective.
To solve this problem we need isolation and a virtual machine is one way to achieve this."><meta name=author content="Nitin"><link rel=canonical href=https://bit-phile.github.io/tech/docker/getting-started-with-docker/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bit-phile.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bit-phile.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bit-phile.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bit-phile.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bit-phile.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Getting Started With Docker"><meta property="og:description" content="Introduction Developing software and applications is getting more complex day by day. This introduces the complexity of running and deploying the applications in different machines or environments. It also includes making sure it works everywhere no matter what the architecture of the host machine is.
Applications running in the same environment can conflict with other applications. This can cause malfunctions and make application development less effective.
To solve this problem we need isolation and a virtual machine is one way to achieve this."><meta property="og:type" content="article"><meta property="og:url" content="https://bit-phile.github.io/tech/docker/getting-started-with-docker/"><meta property="article:section" content="tech"><meta property="article:published_time" content="2023-02-26T11:53:43+05:30"><meta property="article:modified_time" content="2023-03-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Getting Started With Docker"><meta name=twitter:description content="Introduction Developing software and applications is getting more complex day by day. This introduces the complexity of running and deploying the applications in different machines or environments. It also includes making sure it works everywhere no matter what the architecture of the host machine is.
Applications running in the same environment can conflict with other applications. This can cause malfunctions and make application development less effective.
To solve this problem we need isolation and a virtual machine is one way to achieve this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Teches","item":"https://bit-phile.github.io/tech/"},{"@type":"ListItem","position":2,"name":"Getting Started With Docker","item":"https://bit-phile.github.io/tech/docker/getting-started-with-docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Getting Started With Docker","name":"Getting Started With Docker","description":"Introduction Developing software and applications is getting more complex day by day. This introduces the complexity of running and deploying the applications in different machines or environments. It also includes making sure it works everywhere no matter what the architecture of the host machine is.\nApplications running in the same environment can conflict with other applications. This can cause malfunctions and make application development less effective.\nTo solve this problem we need isolation and a virtual machine is one way to achieve this.","keywords":["docker","infra","kubernetes","container","containerisation","containerization"],"articleBody":" Introduction Developing software and applications is getting more complex day by day. This introduces the complexity of running and deploying the applications in different machines or environments. It also includes making sure it works everywhere no matter what the architecture of the host machine is.\nApplications running in the same environment can conflict with other applications. This can cause malfunctions and make application development less effective.\nTo solve this problem we need isolation and a virtual machine is one way to achieve this. We can have different virtual machines to run the applications that will be independent of other applications environments.\nHowever, using a virtual machine has its own pros and cons. Some of these are the followings:\nVirtual Machine Pros Stronger isolation and security as it provides hardware-level isolation which makes them more secure and isolated. Virtual Machine Cons Requires more resources. Virtual machine requires guest system operation to run which consumes more resources. Startup time is more in virtual machines as it has to boot the whole operating system. Portability is less as virtual machines are tied to specific hardware and require additional configurations to run. So, what alternative do we have to achieve this isolated environment? The answer is containerization.\nContainerization Just to get started with this concept, I would like to give an example. We have seen containers that are used on ships to transport things. These containers have isolated environments and temperatures specific to the items they are containing.\nSimilarly, containers can contain applications and supporting libraries required to run the application. This helps in running applications in any environment no matter what host system OS and architecture are.\nDocker Docker is a containerization tool that is used to create and run containers. There are several other alternatives to docker like Podman, openVZ, etc.\nArchitecture Docker uses client-server architecture where the docker client talks with the docker daemon which can run on either a host machine, a virtual machine, or a machine on the cloud. Docker clients can connect to multiple daemons.\nSource: https://docs.docker.com/engine/images/architecture.svg\nDocker client Docker client is an interface that lets users create and run containers. Client talks with docker daemon using Docker API requests. It is not more than an application that can be web-based or cli that sends requests to the server and gets responses back.\nThe server or daemon performs the requested job.\nDocker daemon A Docker daemon is the server that accepts requests from the docker client and performs the respective job. It can run on a host machine or virtual machine. Docker clients can connect to multiple docker daemons and change the daemon using docker client-provided commands.\nFor example,\ndocker context ls It shows available contexts or daemons to which a client can connect to.\nNAME DESCRIPTION DOCKER ENDPOINT KUBERNETES ENDPOINT ORCHESTRATOR default Current DOCKER_HOST based configuration tcp://localhost:2376 swarm desktop-linux unix:///Users/test/.docker/run/docker.sock rancher-desktop * Rancher Desktop moby context unix:///Users/test/.rd/docker.sock To change context, use\ndocker context use rancher-desktop Note: Rancher desktop is an alternative to Docker desktop you can use. Docker desktop requires a license. Rancher desktop creates a lightweight virtual machine on the host system which contains docker components. Docker daemon runs inside that virtual machine.\nDocker Container and Image Container\nAs I mentioned before, a container is a self-contained unit having all the necessary things required for the item container is containing. In this context, a container is a self-contained runnable unit that comprises the application and supporting libraries that are required to run that application.\nImage\nAn image is a blueprint of a container that defines a container. An image contains all the instructions and resources required to create a container.\nIf you have worked on OOPs, you must have heard about classes and objects. You can think of images as classes and objects as containers.\nYou can create your image by using other images as a base. I will show you shortly how to do it.\nRegistry This is the place where you can push your docker images. It’s like GitHub where you push source code onto GitHub and here you would be pushing docker images. You can also pull docker images stored on the docker registry.\nDocker provides a docker hub register where you can get almost all docker images pushed by other people. Visit hub.docker.com for more details.\nDockerfile Dockerfile is used to build docker images. It contains all the instructions required to build an image. Following is an example of a Dockerfile.\nFROM fedora:latest RUN dnf install figlet -y ENTRYPOINT [\"figlet\"] CMD [\"bitPhile\"] Explanation FROM specifies to use fedora:latest as the base image. The base image is the parent image on which your image is based. A new image will be built on top of this base image. RUN instruction is used to run the given command while building the image. ENTRYPOINT is the starting script that will run when the container is started. CMD specifies the default command to run when the container is started. There is a difference between ENTRYPOINT and CMD. When ENTRYPOINT is provided, whatever argument CMD instruction has will be append as arguments to ENTRYPOINT. For instance, if we will see the above example, the final command will be figlet hello world.\nBuilding Docker Image Save the above file and run the following docker command.\ndocker build -t docker-fedora-test . build is the subcommand that tells to build a docker image. -t is a tag where docker-fedora-test is passed as a tag name. . is the context.\nWhat is context? Context the part of the host file system that is required to build a docker image. For example, there may be some file or data which is required in image building. So, we pass those files using context.\nWe can only pass one context.\nA docker image is built through several layers of images. Each of the instructions in Dockerfile runs in a separate image layer. To learn more about docker image layers, refer to my blog docker image layers.\nRunning Docker Image To run the image we’ve just built, run the following docker command.\ndocker run docker-fedora-test This gives output as,\n_ _ _ ____ _ _ _ | |__ (_) |_| _ \\| |__ (_) | ___ | '_ \\| | __| |_) | '_ \\| | |/ _ \\ | |_) | | |_| __/| | | | | | __/ |_.__/|_|\\__|_| |_| |_|_|_|\\___| Awesome, right?\nWe can also pass arguments while we are running the container.\ndocker run docker-fedora-test hello world hello world gets append as an argument to fedora entrypoint command.\nFolks, this is it for now. There are lots of things that come in docker and it is hard to put everything in one place both for you and me. So, see you in the next post on docker. Stay tuned.\nPlease provide your feedback as it helps me improve the posts and get more information to you.\nReferences https://docs.docker.com/engine/reference/builder/ for Dockerfile https://docs.docker.com/get-started/overview/ for overview and architecture ","wordCount":"1155","inLanguage":"en","datePublished":"2023-02-26T11:53:43+05:30","dateModified":"2023-03-18T00:00:00Z","author":{"@type":"Person","name":"Nitin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bit-phile.github.io/tech/docker/getting-started-with-docker/"},"publisher":{"@type":"Organization","name":"bitPhile","logo":{"@type":"ImageObject","url":"https://bit-phile.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bit-phile.github.io/ accesskey=h title="bitPhile (Alt + H)">bitPhile</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Getting Started With Docker</h1><div class=post-meta><span title='2023-02-26 11:53:43 +0530 +0530'>February 26, 2023</span>&nbsp;·&nbsp;Nitin</div></header><div class=post-content><p><img loading=lazy src=/tech/docker/getting-started-with-docker-banner.png alt=Dockerfile-build-docker-image-docker-container title="Dockerfile to docker image to docker container"></p><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>Developing software and applications is getting more complex day by day. This introduces the complexity of running and deploying the applications in different machines or environments. It also includes making sure it works everywhere no matter what the architecture of the host machine is.</p><p>Applications running in the same environment can conflict with other applications. This can cause malfunctions and make application development less effective.</p><p>To solve this problem we need isolation and a virtual machine is one way to achieve this. We can have different virtual machines to run the applications that will be independent of other applications environments.</p><p>However, using a virtual machine has its own pros and cons. Some of these are the followings:</p><h2 id=virtual-machine-pros>Virtual Machine Pros<a hidden class=anchor aria-hidden=true href=#virtual-machine-pros>#</a></h2><ol><li>Stronger isolation and security as it provides hardware-level isolation which makes them more secure and isolated.</li></ol><h2 id=virtual-machine-cons>Virtual Machine Cons<a hidden class=anchor aria-hidden=true href=#virtual-machine-cons>#</a></h2><ol><li>Requires more resources. Virtual machine requires guest system operation to run which consumes more resources.</li><li>Startup time is more in virtual machines as it has to boot the whole operating system.</li><li>Portability is less as virtual machines are tied to specific hardware and require additional configurations to run.</li></ol><p>So, what alternative do we have to achieve this isolated environment? The answer is <strong>containerization</strong>.</p><h1 id=containerization>Containerization<a hidden class=anchor aria-hidden=true href=#containerization>#</a></h1><p>Just to get started with this concept, I would like to give an example. We have seen containers that are used on ships to transport things. These containers have isolated environments and temperatures specific to the items they are containing.</p><p>Similarly, containers can contain applications and supporting libraries required to run the application. This helps in running applications in any environment no matter what host system OS and architecture are.</p><h1 id=docker>Docker<a hidden class=anchor aria-hidden=true href=#docker>#</a></h1><p>Docker is a containerization tool that is used to create and run containers. There are several other alternatives to docker like Podman, openVZ, etc.</p><h2 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h2><p>Docker uses client-server architecture where the docker client talks with the docker daemon which can run on either a host machine, a virtual machine, or a machine on the cloud. Docker clients can connect to multiple daemons.</p><p><img loading=lazy src=/tech/docker/docker-architecture.svg alt=https://docs.docker.com/engine/images/architecture.svg title="Docker architecture">
Source: <a href=https://docs.docker.com/engine/images/architecture.svg>https://docs.docker.com/engine/images/architecture.svg</a></p><h3 id=docker-client>Docker client<a hidden class=anchor aria-hidden=true href=#docker-client>#</a></h3><p>Docker client is an interface that lets users create and run containers. Client talks with docker daemon using Docker API requests. It is not more than an application that can be web-based or cli that sends requests to the server and gets responses back.</p><p>The server or daemon performs the requested job.</p><h3 id=docker-daemon>Docker daemon<a hidden class=anchor aria-hidden=true href=#docker-daemon>#</a></h3><p>A Docker daemon is the server that accepts requests from the docker client and performs the respective job. It can run on a host machine or virtual machine. Docker clients can connect to multiple docker daemons and change the daemon using docker client-provided commands.</p><p>For example,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker context ls
</span></span></code></pre></div><p>It shows available contexts or daemons to which a client can connect to.</p><pre tabindex=0><code>NAME                DESCRIPTION                               DOCKER ENDPOINT                                     KUBERNETES ENDPOINT   ORCHESTRATOR
default             Current DOCKER_HOST based configuration   tcp://localhost:2376                                                      swarm
desktop-linux                                                 unix:///Users/test/.docker/run/docker.sock
rancher-desktop *   Rancher Desktop moby context              unix:///Users/test/.rd/docker.sock
</code></pre><p>To change context, use</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker context use rancher-desktop
</span></span></code></pre></div><blockquote><p>Note: Rancher desktop is an alternative to Docker desktop you can use. Docker desktop requires a license. Rancher desktop creates a lightweight virtual machine on the host system which contains docker components. Docker daemon runs inside that virtual machine.</p></blockquote><h3 id=docker-container-and-image>Docker Container and Image<a hidden class=anchor aria-hidden=true href=#docker-container-and-image>#</a></h3><p><strong>Container</strong></p><p>As I mentioned before, a container is a self-contained unit having all the necessary things required for the item container is containing. In this context, a container is a self-contained runnable unit that comprises the application and supporting libraries that are required to run that application.</p><p><strong>Image</strong></p><p>An image is a blueprint of a container that defines a container. An image contains all the instructions and resources required to create a container.</p><p>If you have worked on OOPs, you must have heard about classes and objects. You can think of images as classes and objects as containers.</p><p>You can create your image by using other images as a base. I will show you shortly how to do it.</p><h3 id=registry>Registry<a hidden class=anchor aria-hidden=true href=#registry>#</a></h3><p>This is the place where you can push your docker images. It&rsquo;s like GitHub where you push source code onto GitHub and here you would be pushing docker images. You can also pull docker images stored on the docker registry.</p><p>Docker provides a docker hub register where you can get almost all docker images pushed by other people. Visit <a href=http://hub.docker.com>hub.docker.com</a> for more details.</p><h2 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h2><p><code>Dockerfile</code> is used to build docker images. It contains all the instructions required to build an image. Following is an example of a <code>Dockerfile</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> fedora:latest</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dnf install figlet -y<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;figlet&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;bitPhile&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=explanation>Explanation<a hidden class=anchor aria-hidden=true href=#explanation>#</a></h3><ol><li><code>FROM</code> specifies to use <code>fedora:latest</code> as the base image. The base image is the parent image on which your image is based. A new image will be built on top of this base image.</li><li><code>RUN</code> instruction is used to run the given command while building the image.</li><li><code>ENTRYPOINT</code> is the starting script that will run when the container is started.</li><li><code>CMD</code> specifies the default command to run when the container is started.</li></ol><blockquote><p>There is a difference between <code>ENTRYPOINT</code> and <code>CMD</code>. When <code>ENTRYPOINT</code> is provided, whatever argument <code>CMD</code> instruction has will be append as arguments to <code>ENTRYPOINT</code>. For instance, if we will see the above example, the final command will be <code>figlet hello world</code>.</p></blockquote><h3 id=building-docker-image>Building Docker Image<a hidden class=anchor aria-hidden=true href=#building-docker-image>#</a></h3><p>Save the above file and run the following docker command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t docker-fedora-test .
</span></span></code></pre></div><p><code>build</code> is the subcommand that tells to build a docker image. <code>-t</code> is a tag where <code>docker-fedora-test</code> is passed as a tag name. <code>.</code> is the context.</p><blockquote><p><strong>What is context?</strong> Context the part of the host file system that is required to build a docker image. For example, there may be some file or data which is required in image building. So, we pass those files using context.</p><p>We can only pass one context.</p></blockquote><p>A docker image is built through several layers of images. Each of the instructions in <code>Dockerfile</code> runs in a separate image layer. To learn more about docker image layers, refer to my blog <a href=/tech/docker/docker-image-layers/>docker image layers</a>.</p><h3 id=running-docker-image>Running Docker Image<a hidden class=anchor aria-hidden=true href=#running-docker-image>#</a></h3><p>To run the image we&rsquo;ve just built, run the following docker command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run docker-fedora-test
</span></span></code></pre></div><p>This gives output as,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> _     _ _   ____  _     _ _
</span></span><span style=display:flex><span>| |__ <span style=color:#f92672>(</span>_<span style=color:#f92672>)</span> |_|  _ <span style=color:#ae81ff>\|</span> |__ <span style=color:#f92672>(</span>_<span style=color:#f92672>)</span> | ___
</span></span><span style=display:flex><span>| <span style=color:#e6db74>&#39;_ \| | __| |_) | &#39;</span>_ <span style=color:#ae81ff>\|</span> | |/ _ <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>| |_<span style=color:#f92672>)</span> | | |_|  __/| | | | | |  __/
</span></span><span style=display:flex><span>|_.__/|_|<span style=color:#ae81ff>\_</span>_|_|   |_| |_|_|_|<span style=color:#ae81ff>\_</span>__|
</span></span></code></pre></div><p>Awesome, right?</p><p>We can also pass arguments while we are running the container.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run docker-fedora-test hello world
</span></span></code></pre></div><p><code>hello world</code> gets append as an argument to <code>fedora</code> entrypoint command.</p><p>Folks, this is it for now. There are lots of things that come in docker and it is hard to put everything in one place both for you and me. So, see you in the next post on docker. Stay tuned.</p><p>Please provide your feedback as it helps me improve the posts and get more information to you.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ol><li><a href=https://docs.docker.com/engine/reference/builder/>https://docs.docker.com/engine/reference/builder/</a> for <code>Dockerfile</code></li><li><a href=https://docs.docker.com/get-started/overview/>https://docs.docker.com/get-started/overview/</a> for overview and architecture</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://bit-phile.github.io/tags/docker/>docker</a></li><li><a href=https://bit-phile.github.io/tags/infra/>infra</a></li><li><a href=https://bit-phile.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=https://bit-phile.github.io/tags/container/>container</a></li><li><a href=https://bit-phile.github.io/tags/containerisation/>containerisation</a></li><li><a href=https://bit-phile.github.io/tags/containerization/>containerization</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bit-phile.github.io/>bitPhile</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>